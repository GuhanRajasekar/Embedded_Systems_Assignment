#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>  //as we need to use atoi() function
#include <./inc/tm4c123gh6pm.h>
#include <inc/hw_memmap.h>
#include <inc/hw_types.h>
#include <driverlib/gpio.h>
#include <driverlib/pin_map.h>
#include <driverlib/sysctl.h>
#include <driverlib/uart.h>
#include <ctype.h>
#include <main.h>
#include "sine_table.h"
#include "periph_ctl.h"
#include "HeapMem.h"

// Function to initialize Ports A and B
void Init_PortAB(void)
{
    SYSCTL_RCGC2_R |= 0x00000023;
    GPIO_PORTA_CR_R = 0xF0;
    GPIO_PORTB_CR_R = 0xFF;

    GPIO_PORTA_AMSEL_R = 0x00;
    GPIO_PORTB_AMSEL_R = 0x00;

    GPIO_PORTB_DIR_R = 0xFF;
    GPIO_PORTA_DIR_R = 0xF0;

    GPIO_PORTB_AFSEL_R = 0x00;
    GPIO_PORTA_AFSEL_R = 0x00;

    GPIO_PORTB_DEN_R = 0xFF;
    GPIO_PORTA_DEN_R = 0xF0;
}

void Init_PortC(void)
{
    // Initializing PORT C for 4x4  KeyPad Interfacing
    SYSCTL_RCGC2_R    |= 0x00000004 ;       /* Enable clock to GPIO_C_ at clock gating control register */
    SYSCTL_RCGCGPIO_R |= 0x00000004 ;       /* Enable and provide a clock to GPIO Port_C_ in Run mode */
    GPIO_PORTC_DIR_R  &= ~ 0xF0 ;           /*  GPIO Direction | 0 -> INPUT | 1 -> OUTPUT (We are configuring PORTC as input and connecting it to columns of 4x4 Keypad)*/
    GPIO_PORTC_ODR_R |= 0xF0 ;              /* 1 -> The corresponding pin is configured as open drain */
    GPIO_PORTC_DEN_R |= 0xF0;               /* enable the GPIO pins for digital function */
    GPIO_PORTC_PUR_R |= 0xF0 ;              /* 1 -> The corresponding pin's weak pull-up resistor is enabled */

    // Interrupt setup for 4x4 keypad in  PORTC
    // Interrupt sense register sets value for bits PC7 - PC4. (1 - level triggered, 0 - edge triggered)
    GPIO_PORTC_IS_R &= ~(0xF0);
    // Interrupt Both Edges is not set
    GPIO_PORTC_IBE_R &= ~(0xF0);

    // If both edges not set then
    // Trigger controlled by IEV (Interrupt Even Register) for negative/positive or rising/falling
    GPIO_PORTC_IEV_R &= ~(0xF0);

    // Clearing previous interrupts if any
    // For edge triggered interrupts, writing a 1 clears the interrupts
    GPIO_PORTC_ICR_R |= (0xF0);

    // Unmask interrupt for PC7 - PC4 (Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal)
    GPIO_PORTC_IM_R |= 0xF0;

    // set interrupt priority = 2 for PORTC
    NVIC_PRI0_R = (NVIC_PRI0_R & 0xFF00FFFF) | 0x00400000;
    NVIC_EN0_R = 0x00000004;        // NVIC enabled for PORTC (IRQ number = 2)
}

// Function to initialize Port E
void Init_PortE(void)
{
    // Initializing PORT E  for 4x4 Keypad Interfacing
    SYSCTL_RCGC2_R    |= 0x00000010 ;       /* Enable clock to GPIO_E_ at clock gating control register */
    SYSCTL_RCGCGPIO_R |= 0x00000010 ;       /* Enable and provide a clock to GPIO Port_E_ in Run mode */
    GPIO_PORTE_DIR_R  |= 0x0F ;             /*  GPIO Direction | 0 -> INPUT | 1 -> OUTPUT  (We are configuring PORTE as output and connecting it to rows of 4x4 Keypad)*/
    GPIO_PORTE_DEN_R  |= 0x0F;              /* enable the GPIO pins for digital function */
    GPIO_PORTE_DATA_R  = 0x00 ;             /* Initializing PORTE Data to all 0s*/
}

// Function to initialize Port F
void Init_PortF(void)
{
    SYSCTL_RCGC2_R |= 0x00000020; /* Activate Clock for PORTF */
//    delay = SYSCTL_RCGC2_R; /* Allow time for clock to start*/
    GPIO_PORTF_DIR_R =  0x0E;  /* enable the GPIO pins for the LED (PF3, 2 1) as output */
    GPIO_PORTF_LOCK_R = 0x4C4F434B;   /* unlock commit register GPIOCR */
    GPIO_PORTF_CR_R = 0x0E;
    GPIO_PORTF_AMSEL_R = 0x00; /* disable analog on PF*/
    GPIO_PORTF_PCTL_R = 0x00000000; /* PCTL GPIO on PF4 - PF0*/
    GPIO_PORTF_DIR_R = 0x0E; /* PF4, PF0 as inputs and (PF3, PF2 ,PF1) as input pins*/
    GPIO_PORTF_AFSEL_R = 0x00; /* disable alternate function on PF7 - PF0*/
    GPIO_PORTF_PUR_R = 0x00; /* enable pull up on PF0 and PF4*/
    GPIO_PORTF_DEN_R = 0x0E;
}

// Function to initialize Systick Timer
void Init_Systick(void)
{
    NVIC_ST_RELOAD_R = 15999999; // reload value corresponding to 1 second
    NVIC_ST_CTRL_R = 7;
    NVIC_SYS_PRI3_R= (NVIC_SYS_PRI3_R & 0x1fffffff) | 0x60000000;
}

// Function to initialize the dummy stack for the all the background tasks
void Set_initial_stack(int i)
{
    tcbs[i].sp = &stacks[i][STACK_SIZE-16]; // Initializing Stack Pointer
    stacks[i][STACK_SIZE - 1] = 0x01000000; // Thumb mode
    stacks[i][STACK_SIZE-3] = 1;   // R14
    stacks[i][STACK_SIZE-4] = 2;   // R12
    stacks[i][STACK_SIZE-5] = 3;   // R3
    stacks[i][STACK_SIZE-6] = 4;   // R2
    stacks[i][STACK_SIZE-7] = 5;   // R1
    stacks[i][STACK_SIZE-8] = 6;   // R0
    stacks[i][STACK_SIZE-9] = 7;   // R11
    stacks[i][STACK_SIZE-10] = 8;  // R10
    stacks[i][STACK_SIZE-11] = 9;  // R9
    stacks[i][STACK_SIZE-12] = 10; // R8
    stacks[i][STACK_SIZE-13] = 11; // R7
    stacks[i][STACK_SIZE-14] = 12; // R6
    stacks[i][STACK_SIZE-15] = 13; // R5
    stacks[i][STACK_SIZE-16] = 14; // R4.  Stack Pointer will be pointing to this location.

}


// Function to set up a doubly linked list structure that connects TCBs of all the individual tasks
//void OS_AddThreads(void (*task0)(void), void(*task1)(void), void(*task2)(void) , void(*task3)(void), void(*task4)(void) )
void OS_AddThreads()
{
    // Here we form a circular linked list structure chaining all the main threads
    tcbs[0].next = &tcbs[1];
    tcbs[1].next = &tcbs[2];
    tcbs[2].next = &tcbs[3];
    tcbs[3].next = &tcbs[4];
    tcbs[4].next = &tcbs[5];
    tcbs[5].next = &tcbs[0];

    // Assigning priorities to each task (lower the number, higher the priority)
    for(int pri = 0; pri < THREAD_NUM ; pri++)
    {
        tcbs[pri].priority = pri;
    }


    Set_initial_stack(0);  // Set up dummy stack for task0 that will be used to save the context for task 0
    stacks[0][STACK_SIZE-2] = (long)(task0); // store the function pointer of task0 in the last but first location of the dummy array of task0

    Set_initial_stack(1); // Set up dummy stack for task1 that will be used to save the context for task 1
    stacks[1][STACK_SIZE-2] = (long)(task1);  // store the function pointer of task1 in the last but first location of the dummy array of task1

    Set_initial_stack(2); // Set up dummy stack for task2 that will be used to save the context for task 2
    stacks[2][STACK_SIZE-2] = (long)(task2);  // store the function pointer of task2 in the last but first location of the dummy array of task2

    Set_initial_stack(3); // Set up dummy stack for task3 that will be used to save the context for task 3
    stacks[3][STACK_SIZE-2] = (long)(task3);  // store the function pointer of task3 in the last but first location of the dummy array of task3

    Set_initial_stack(4);  // Set up dummy stack for task4 that will be used to save the context for task 4
    stacks[4][STACK_SIZE-2] = (long)(task4); // store the function pointer of task4 in the last but first location of the dummy array of task4

    Set_initial_stack(5);  // Set up dummy stack for task5 that will be used to save the context for task 5
    stacks[5][STACK_SIZE-2] = (long)(task5); // store the function pointer of task5 in the last but first location of the dummy array of task5

    runpt = &tcbs[0]; // Make runpt point to tcb of the first task
}


// Function to make it look like the system was already in steady state
void start_os(void)
{
    asm("LDR R0, =runpt");  // Store the address of "runpt" in register R0
    asm("LDR R2,[R0]");     // Dereference R0 to get the "runpt" value. Store runpt in register R2
    asm("LDR SP,[R2]");     // Dereference R2 => Dereference runpt => This gives sp value. Store sp of that particular task in the actual SP register.
    asm("POP {R4-R11}");    // Get the contents in the next 8 locations of the stack memory and store it in registers R4 to R11 => Saving the context
    asm("POP {R0 - R3}");   // Get the contents in the next 4 locations of the stack memory and store it in registers R0 to R3  => Saving the context
    asm("POP {R12}");       // Get the content pointed to by the stack pointer and store it in register R12 => Saving the context
    asm("POP {LR}");
    asm("POP {LR}");  // to get to the position where function pointer of that particular task is stored
    asm("POP {R1}");
    asm("CPSIE I");   // Enable the interrupts
    asm("BX LR");  // BX is branch instruction
}

// Memory Management related functions start from this point
int HeapMemInit(void *pStartAddr, int iHeapSize, int iUnitSize)
{
    if(HeapInitFlag ==0)  // The flag check makes sure that heap memory initialization is done only once
    {
        pHeapStartAddr = pStartAddr;   // The starting address of the heap memory section is mentioned in "pStartAddr"
        HeapSize = iHeapSize;          // Total size of the requested memory is mentioned in "iHeapSize"

        //iUnitSize indicates the units in which the requested memory chunk will be allocated.
        // For example if iHeapSize is 127 and iUnitsize is 64, then 2 blocks of 64 bytes will be allocated
        if(iUnitSize == 16||iUnitSize == 32||iUnitSize == 64||iUnitSize == 128)
            HeapUnitSize = iUnitSize;
        else HeapUnitSize = 16;        // Default value of HeapUnitSize if iUnitSize is not 16,32,64 or 128

        BlockHeaderSize = sizeof(BLOCK_HEADER); // BlockHeaderSize is the size of the structure BLOCK_HEADER (32 bytes when compiled with VSCode)

        // Need to maintain two lists : "Used Block" and "Free Block"
        // These blocks are initialized as follows
        psFirstUsedBlock = (BLOCK_HEADER *)pHeapStartAddr; //psFirstUsedBlock stores the starting address of the heap memory section
        psFirstUsedBlock->uiBlockID = uiBlockID++; // psFirstUsedBlock->uiBlockID = 0. uiBlockID is unique for each block of memory
        psFirstUsedBlock->pParentBlock = NULL; // First used block of memory has no parent block
        psFirstUsedBlock->pChildBlock = NULL;  // First used block of memory is initialized with no child
        psFirstUsedBlock->uiSize = 0;          //

        // another way of saying this would be psFirstFreeBlock = psFirstUsedBlock + 1
        psFirstFreeBlock = (BLOCK_HEADER *)(pHeapStartAddr+BlockHeaderSize); //psFirstFreeBlock will point to the location after psFirstUsedBlock
        psFirstFreeBlock->uiBlockID = uiBlockID++; // psFirstFreeBlock->uiBlockID = 1
        psFirstFreeBlock->pParentBlock = NULL; // First Free block of memory has no parent block
        psFirstFreeBlock->pChildBlock = NULL;  // First Free block of memory is initialized with no child

        // uiSize of psFirstFreeBlock indicates the total available memory after the initialization of the first free block and the first used block
        psFirstFreeBlock->uiSize = HeapSize - (BlockHeaderSize*2);


        HeapInitFlag =1;     // To make sure that heap memory intialization is done only once
        return HEAP_SUCCESS; // HEAP_SUCCESS is a macro with value 1
    }
    else return HEAP_ERROR;  // HEAP_ERROR   is a macro with value 0
}

//allocated memory is greater than or equal to no_of_bytes that is requested by the user
void * MemAlloc(int iNumBytes)
{
    BLOCK_HEADER *FreeBlock,*NewFreeBlock,*NewUsedBlock; // These are all pointers to structure BLOCK_HEADER
    void *pData; // void pointer
    int iSize;

    // iNumBytes is the size of the requested memory in bytes
    // iSize is the allocated size of memory which is in multiples of " HeapUnitSize "
    // iSize will always be greater than or equal to iNumBytes
    // Because allocating memory greater than or equal to the requested amount is OK but allocating less than the requested amount is NOT OK
    iSize = FindAllocSize(iNumBytes);

    FreeBlock =(BLOCK_HEADER *)FindUsableFreeBlock(iSize);
    if(FreeBlock == NULL)
        return NULL;
    else
    {
        // Available memory space >= (allocated memory + BlockHeaderSize)
        // The allocated memory must have a label (BlockHeaderSize) attached to it.
        // Hence while allocating memory, we check if we have enough memory for "user requested space(iSize)" and a label(BlockHeaderSize) for the user requested space
        if(FreeBlock->uiSize >= (iSize + BlockHeaderSize))
        {
            //iSize + BlockHeaderSize will be allocated to the user (user requested space + label for the user requested space)
            // the NewFreeBlock is the location after that , hence NewFreeBlock = (Old Free Block) + (User Requested Space) + (Label for the user requested space)
            NewFreeBlock = (BLOCK_HEADER *)(((unsigned int)FreeBlock) + iSize + BlockHeaderSize); // NewFreeBlock points to the location of (Intial free block + requested memory space)

            // Here we set up the connection between the FreeBlock and NewFreeBlock. NewFreeBlock is made the child node of FreeBlock
            // Available free size is now updated as (old available size) - ((user requested space) + (label for the user requested space)) => Third argument in the InsertBlock Function
            InsertBlock(FreeBlock,NewFreeBlock,(FreeBlock->uiSize - (iSize + BlockHeaderSize)));
            DeleteBlock(FreeBlock, FREE_BLOCK); // Since a section has been used, it must be removed from "free" block section
            NewUsedBlock = FreeBlock; // What was originally FreeBlock now becomes the "NewUsedBlock".

            // Now we need to make the connection between the first used block and the newused block
            // NewUsedBlock becomes the child node of the psFirstUsedBlock (Recall that originally child node of psFirstUsedBlock was set to NULL in HeapMemInit() function )
            InsertBlock(psFirstUsedBlock,NewUsedBlock,iSize);

            // We return NewUsedBlock + BlockHeaderSize because every allocated chunk of memory will have a label (BlockHeaderSize)
            // The user can use the portion that is present after the label (BlockHeaderSize)
            // Hence we return NewUsedBlock(Starting point) + BlockHeaderSize
            pData = (void*)((unsigned int)NewUsedBlock + BlockHeaderSize);
            return pData;
        }

        // Available memory space < (allocated memory + BlockHeaderSize)
        else
        {
            iSize = FreeBlock->uiSize; // Set iSize to the available size
            if(HEAP_SUCCESS == DeleteBlock(FreeBlock, FREE_BLOCK))
            {
                NewUsedBlock = FreeBlock; // // What was originally FreeBlock now becomes the "NewUsedBlock".

                // Now we need to make the connection between the first used block and the newused block
                // NewUsedBlock becomes the child node of the psFirstUsedBlock
                InsertBlock(psFirstUsedBlock,NewUsedBlock,iSize);
                pData = (void*)((unsigned int)NewUsedBlock + BlockHeaderSize);
                return pData;
            }
            else
                return NULL;
        }
    }
}

int FindAllocSize(int iNumBytes)
{
    int Count;

    // HeapUnitSize is initialized in the function HeapMemInit()
    Count = iNumBytes /HeapUnitSize;

    // Assume iNumBytes = 127 and HeapUnitSize = 64. In this case Count = 127/64 = 1 as Count is "int" type variable
    // But for 127 bytes of memory , we need two units of "64" bytes of memory (extra space is OK but less than what is required is NOT OK)
    // Hence, in this case iNumBytes > (Count*HeapUnitSize) => 127 > (1*64) => Count is made 2
    // And we return (Count*HeapUnitSize) => (2*64) => 128 bytes of memory
    // So this function makes sure that we always return a chunk of memory that is greater than or equal to what is required, but never below it.
    if(iNumBytes > (Count*HeapUnitSize))Count += 1;

    return (Count*HeapUnitSize);
}

void* FindUsableFreeBlock(int iSize)
{
    BLOCK_HEADER *CurrentBlock;  // Current Block is a pointer pointing to a vriable of structure type BLOCK_HEADER

    // The "psFirstFreeBlock" was initialized with the location of the first free memory section in the function HeapMemInit()
    CurrentBlock = psFirstFreeBlock;
    while (CurrentBlock->uiSize < iSize)
    {
        if(CurrentBlock->pChildBlock == NULL)
        {
            return NULL;
        }
        else
        {
            CurrentBlock = (BLOCK_HEADER *)(CurrentBlock->pChildBlock);
        }
    }
    return CurrentBlock;
}

int InsertBlock(void *pCurrentBlock, void *pNewBlock, int iSize)
{
    BLOCK_HEADER *CurrentBlock,*NewBlock,*ChildBlock;

    CurrentBlock = (BLOCK_HEADER *)pCurrentBlock;
    NewBlock = (BLOCK_HEADER *)pNewBlock;

    NewBlock->uiBlockID = uiBlockID++;      // incrementing the block ID for the new block of memory
    NewBlock->pParentBlock = CurrentBlock;  // Current block becomes the parent block for the new block
    NewBlock->pChildBlock = CurrentBlock->pChildBlock;

    // Similar to inserting a node in a linked list
    if(CurrentBlock->pChildBlock != NULL)
    {
        ChildBlock = (BLOCK_HEADER *)CurrentBlock->pChildBlock;
        ChildBlock->pParentBlock = NewBlock;
    }
    NewBlock->uiSize = iSize;

    CurrentBlock->pChildBlock = NewBlock ;

    // This function changes " CurrentBlock -> ChildBlock"  to " CurrentBlock -> NewBlock -> ChildBlock"

    return HEAP_SUCCESS;
}

int DeleteBlock(void *pBlock,  int BlockType)
{
    BLOCK_HEADER *Block,*ParentBlock,*ChildBlock;

    Block = (BLOCK_HEADER *)pBlock;

    if((Block->pParentBlock == NULL) && (Block->pChildBlock == NULL)) //Pivot Block Cannot be deleted
    {
        return HEAP_ERROR;
    }
    else
    {
        // Similar to deleting the first node of a linkedlist
        if(Block->pParentBlock == NULL) // if it was the first block (first block has no parent block)
        {
            ChildBlock = (BLOCK_HEADER *)(Block->pChildBlock);
            ChildBlock->pParentBlock = NULL;
            if(BlockType == FREE_BLOCK)
                 psFirstFreeBlock = ChildBlock;
            else if(BlockType == USED_BLOCK)
                 psFirstUsedBlock = ChildBlock;
        }

        // Similar to deleting the last node of a linked list
        else if (Block->pChildBlock == NULL)// if it was the last block (last block has no child block)
        {
            ParentBlock = (BLOCK_HEADER *)(Block->pParentBlock);
            ParentBlock->pChildBlock = NULL;
        }

        // Similar to deleting an intermediate node of the linked list
        else
        {
            ChildBlock = (BLOCK_HEADER *)(Block->pChildBlock);
            ParentBlock = (BLOCK_HEADER *)(Block->pParentBlock);
            ChildBlock->pParentBlock = ParentBlock;
            ParentBlock->pChildBlock = ChildBlock;
        }
        return HEAP_SUCCESS;
    }
}

//Frees up the chunks (a block) of allocated memory and makes it available for the future use
int MemFree(void *pData)
{
    BLOCK_HEADER *UsedBlock,*NewFreeBlock;
    int iSize;

    UsedBlock = (BLOCK_HEADER *)((unsigned int)pData - BlockHeaderSize);
    iSize = UsedBlock->uiSize;
    if(HEAP_SUCCESS == DeleteBlock(UsedBlock, USED_BLOCK))
    {
        NewFreeBlock = UsedBlock;
        InsertBlock(psFirstFreeBlock,NewFreeBlock,iSize);
        MergeFreeBlocks();
        return HEAP_SUCCESS;
    }
    else return HEAP_ERROR;
}

void MergeFreeBlocks(void)
{
    BLOCK_HEADER *CurrentBlock, *NextBlock;
    unsigned int CurrentBlockEnd;

    CurrentBlock = psFirstFreeBlock;

    while (CurrentBlock != NULL)
    {
        CurrentBlockEnd = (((unsigned int)CurrentBlock) + BlockHeaderSize + CurrentBlock->uiSize);
        NextBlock = psFirstFreeBlock;
        while (NextBlock != NULL)
        {
            if((unsigned int)NextBlock == CurrentBlockEnd)
            {
                CurrentBlock->uiSize += (NextBlock->uiSize + BlockHeaderSize);
                DeleteBlock(NextBlock, FREE_BLOCK);
                break;
            }
            NextBlock = (BLOCK_HEADER *)(NextBlock->pChildBlock);
        }
        CurrentBlock = (BLOCK_HEADER *)(CurrentBlock->pChildBlock);
    }
}


int main()
{
    DisableInterrupts();                                 // Disable the interrupts
    heap_start = (unsigned int)&__heap_start__;          // storing the start  address of heap memory section
    heap_end   = (unsigned int)&__heap_end__;            // storing the ending address of heap memory section
    mem = HeapMemInit((void*)heap_start, 128 , 16);      // Heap memory initialization (128 bytes of memory in chunks of 16 bytes)
    Init_PortAB();                                       // Initialize ports A and B
    Init_PortC();                                        // Initialize Port C
    Init_PortE();                                        // Intialize Port E
    Init_PortF();                                        // Initialize Port F
    Init_Systick();                                      // Initialize Systick Timer

    configure_spi();                                     // Configure the spi to send values to DAC
    OS_AddThreads();                                     // Form a linked list, chaining the TCBs of the tasks together
    //    OS_AddThreads(&task0, &task1, &task2, &task3, &task4);
    start_os();
    return 0; // Program Control never reaches this point
}

/* task 0 makes the RED LED ON continuously and also displays the count on the right most SSD*/
void task0(void)
{
    int i = 0;
    while(1)
    {
        GPIO_PORTF_DATA_R = 0x02;  // red color LED
        if(i > 9)
            i = 0;
        else i++;

        for(int j1 = 0; j1<1000000; j1++) // slower task (1200000)
            asm("NOP");
        (GPIO_PORTA_DATA_R = 0x10); //PA4 is made high => Right most SSD is chosen
        GPIO_PORTB_DATA_R = NUMto7SEG[i];
    }
}

/* task 1 makes the BLUE LED ON continuously and displays its count on the second SSD from the right*/
void task1(void)
{
    int j = 0;
    while(1)
    {
        GPIO_PORTF_DATA_R = 0x04;  // Blue LED

             if(j>9)
                j=0;

             else j++;

             for(int j1 = 0; j1<1000000; j1++) //(1000000)
                     asm("NOP");

             (GPIO_PORTA_DATA_R = 0x20); // PA5 = 1 => Second LED from the right is chosen
             GPIO_PORTB_DATA_R = NUMto7SEG[j]; // Display the count value indicated by j
    }
}

/* task 2 makes the GREEN LED ON continuously and displays its count on the third SSD from the right*/
void task2(void)
{
    int k = 0;
    while(1)
    {
        GPIO_PORTF_DATA_R = 0x08;  // Green color LED
              if(k>9)
                  k = 0;
              else k++;

              for(int j1=0;j1<1000000;j1++) // 1000000
                   asm("NOP");
              (GPIO_PORTA_DATA_R = 0x40);  // Third SSD from the right is chosen
              GPIO_PORTB_DATA_R = NUMto7SEG[k]; // Display the value indicated by k on the SSD
    }
}

/* task 3 makes the WHITE LED ON continuously and displays its count on the second SSD from the right*/
void task3(void)
{
        int l = 0;
        while(1)
        {
            GPIO_PORTF_DATA_R = 0x0e;  // white LED
                  if(l>9)
                      l = 0;

                  else l++;

                  for(int j1=0;j1<1000000; j1++) //400000
                      asm("NOP");
                  (GPIO_PORTA_DATA_R = 0x80);  // PA7 = 1 => Left most SSD is chosen
                  GPIO_PORTB_DATA_R = NUMto7SEG[l]; // Count value indicated by l is displayed on the left most SSD
        }
}

/*task 4 keeps Magenta LED ON sends value to LTC1661 DAC to generate sinusoidal waveform and view it on the oscilloscope*/
void task4(void)
{
  while(1)
  {
       GPIO_PORTF_DATA_R = 0x06;             // Magenta LED
       sin_index = (sin_index+1)%127;        // Increment the index to send the next value
       data      =  sine[sin_index];         // Pick a value to be sent from the look up table
       unsigned int command   =  0x9000;     // To send value on Channel A
       debug_var[4] = data;                  // This will be used for viewing purposes

       int temp =  GPIO_PORTF_DATA_R ;
       unsigned temp_data = ((data<<2)|(command));
       GPIO_PORTF_DATA_R &= ~0x04; /* assert SS low */
       while((SSI3_SR_R & 2) == 0);/* wait until FIFO not full */
       SSI3_DR_R = (temp_data>>8);
       while(SSI3_SR_R & 0x10);    /* wait until transmit complete */
       SSI3_DR_R = temp_data;      /* transmit high byte */
       while(SSI3_SR_R & 0x10);    /* wait until transmit complete */
       GPIO_PORTF_DATA_R |= 0x04;
       GPIO_PORTF_DATA_R = temp;   /* keep SS idle high */
  }
}


void task5(void)
{

   void* ptr;
   int flag = 0;
   int* ptr_task5;
   while(1)
   {
       GPIO_PORTF_DATA_R = 0x0A;             // Yellove LED
       if(mem == 1)  // Heap Memory Initialization was successful
       {
          if(flag == 0)
          {
              ptr = MemAlloc(16);      // Request 16 bytes of memory from Heap Section
              ptr_task5 = (int *)ptr;  // Store the starting address of allocated memory in ptr_task5 pointer
              *ptr_task5 = 0;          // Initialize 0 in the location pointed to by ptr_task5
              flag = 1;
          }
          else
          {
              debug_var[5] = *ptr_task5;
              *ptr_task5 = *ptr_task5 + 1;
              for(int i=1;i<=500;i++) delay_1ms();  // wait for 0.5s
              if(*ptr_task5 == 11)
              {
                  MemFree(ptr);  // To Free up the memory
                  flag = 0;      // Start the process all over again
              }
          }

       }
   }

}

// Function to enable interrupts
void EnableInterrupts(void)
{
    __asm ("     CPSIE I\n");
}

// Function to disable interrupts
void DisableInterrupts(void)
{
    __asm("    CPSID  I\n");
}


// Systick_Handler() function is the preemptive scheduler that will determine which background task needs to be run next
__attribute__((naked))        // DOUBT : What does naked do ???
void SysTick_Handler(void)
{
    // The following 5 lines of assembly code will help us save the context of the background task that is currently running
    asm("CPSID I");           // Disable the interrupts. This is done to prevent interrupts when we switch from one task to another
    asm("PUSH {R4-R11}");     // Pushing the contents of R4-R11 on to the dummy array that acts as stack for each task
    asm("LDR R0, =runpt");    // Store the address of runpt in R0
    asm("LDR R1, [R0]");      // Dereference R0 to get "runpt". Store "runpt" in R1 register
    asm("STR SP,[R1]");       // Store the value of actual SP in the "sp" pointer of the tcb structure of that particular task

    // If count value is greater than 0 perform the same task again
    if(count > 0) count -= 1;

    // If the count for the current task has been exhausted, then move on to the next task (Compute the count value for the new task to be executed)
    else
    {
        runpt = runpt->next;             //make runpt point to the tcb of the next task to be performed
        switch(runpt->priority)
        {
           case 0:  count = 10; break; // count = 10;
           case 1:  count = 5;  break; // count =  5;
           case 2:  count = 2;  break; // count =  2;
           case 4:  count = 1;  break; // count = 15;
           default: count =  1; break;
        }
    }

    // The next 5 steps will help us switch from one task to another
    asm("LDR R0, =runpt");
    asm("LDR R1, [R0]");
    asm("LDR SP,[R1]");       // Dereferencing R1 gives "sp" of the new task. This value is loaded to SP so that SP now points to the dummy array of the task that needs to be executed
    asm("POP {R4-R11}");      // Transfer the contents of the new task on to the registers R4 - R11 and start executing the new task
    asm("CPSIE I");           // Enable interrupts
    asm("BX LR");             // What does this do ?

}



// Function to handle key press as interrupts
void GPIO_PORTC_Handler(void)
{
    debug_var[0]+= 1;
    if((GPIO_PORTC_DATA_R & 0xF0) != 0xF0)  // Key Press Detected
    {
        debug_var[1] += 1;
        GPIO_PORTE_DATA_R = 0x07; // Driving PE3 low   (Last row driven low)
        debug_var[2] = GPIO_PORTE_DATA_R;

        debug_var[3] = GPIO_PORTC_DATA_R & 0xF0;     // Getting the data in PC7-PC4
        if((GPIO_PORTC_DATA_R & 0xF0) == 0xE0)
        {
            // Dynamically change the priorities of the tasks here
            for(int wait = 0; wait<80; wait++) delay_1ms();
            for(int i=0;i<THREAD_NUM;i++)      tcbs[i].priority = (tcbs[i].priority + 1) % THREAD_NUM;

        }
    }
    GPIO_PORTC_ICR_R = 0xF0; // Clearing the interrupts
}

// Function to add a delay of 1ms
void delay_1ms(void)
{

    for(int j = 0; j<3180; j++) //3180
       {
            // Do nothing for 1 ms
       }
}

